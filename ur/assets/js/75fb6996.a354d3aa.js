"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[709],{5973:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Humanoid/kinematics","title":"Chapter 1: Humanoid Robot Kinematics","description":"1.1 Introduction to Kinematics","source":"@site/docs/05-Humanoid/01-kinematics.md","sourceDirName":"05-Humanoid","slug":"/Humanoid/kinematics","permalink":"/Physical-AI-Book/ur/Humanoid/kinematics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 6: Reinforcement Learning for Robotics","permalink":"/Physical-AI-Book/ur/Isaac/reinforcement-learning"},"next":{"title":"Chapter 2: Humanoid Robot Dynamics","permalink":"/Physical-AI-Book/ur/Humanoid/dynamics"}}');var a=n(4848),o=n(8453);const r={},s="Chapter 1: Humanoid Robot Kinematics",c={},l=[{value:"1.1 Introduction to Kinematics",id:"11-introduction-to-kinematics",level:2},{value:"1.1.1 Forward Kinematics",id:"111-forward-kinematics",level:3},{value:"1.1.1.1 Denavit-Hartenberg (DH) Parameters",id:"1111-denavit-hartenberg-dh-parameters",level:4},{value:"1.1.1.1.1 Transformation Matrices",id:"11111-transformation-matrices",level:5},{value:"1.1.1.1.1.1 Matrix Chain Multiplication",id:"111111-matrix-chain-multiplication",level:6},{value:"1.2 Inverse Kinematics (IK)",id:"12-inverse-kinematics-ik",level:2},{value:"1.2.1 Analytical vs. Numerical Solutions",id:"121-analytical-vs-numerical-solutions",level:3},{value:"1.2.1.1 Jacobian Matrix",id:"1211-jacobian-matrix",level:4},{value:"1.2.1.1.1 Redundancy and Optimization",id:"12111-redundancy-and-optimization",level:5},{value:"1.2.1.1.1.1 Workspace Analysis",id:"121111-workspace-analysis",level:6}];function d(e){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"chapter-1-humanoid-robot-kinematics",children:"Chapter 1: Humanoid Robot Kinematics"})}),"\n",(0,a.jsx)(i.h2,{id:"11-introduction-to-kinematics",children:"1.1 Introduction to Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Kinematics is the study of motion without considering the forces that cause it. In humanoid robotics, kinematics deals with the geometric relationships between the joints and links of the robot and its end-effectors."}),"\n",(0,a.jsx)(i.h3,{id:"111-forward-kinematics",children:"1.1.1 Forward Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Forward kinematics calculates the position and orientation of the robot's end-effectors (e.g., hands, feet) given the angles or positions of its joints."}),"\n",(0,a.jsx)(i.h4,{id:"1111-denavit-hartenberg-dh-parameters",children:"1.1.1.1 Denavit-Hartenberg (DH) Parameters"}),"\n",(0,a.jsx)(i.p,{children:"DH parameters are a standard convention for describing the kinematic chain of a robot arm using a set of four parameters (link length, link twist, joint offset, joint angle) per joint."}),"\n",(0,a.jsx)(i.h5,{id:"11111-transformation-matrices",children:"1.1.1.1.1 Transformation Matrices"}),"\n",(0,a.jsx)(i.p,{children:"Homogeneous transformation matrices are used to represent the position and orientation of each link's coordinate frame relative to the previous link, allowing for the calculation of the end-effector pose."}),"\n",(0,a.jsx)(i.h6,{id:"111111-matrix-chain-multiplication",children:"1.1.1.1.1.1 Matrix Chain Multiplication"}),"\n",(0,a.jsx)(i.p,{children:"The overall transformation from the robot's base to its end-effector is found by multiplying the individual transformation matrices along the kinematic chain."}),"\n",(0,a.jsx)(i.h2,{id:"12-inverse-kinematics-ik",children:"1.2 Inverse Kinematics (IK)"}),"\n",(0,a.jsx)(i.p,{children:"Inverse kinematics is the reverse problem: calculating the required joint angles to achieve a desired end-effector position and orientation. This is a more challenging problem than forward kinematics."}),"\n",(0,a.jsx)(i.h3,{id:"121-analytical-vs-numerical-solutions",children:"1.2.1 Analytical vs. Numerical Solutions"}),"\n",(0,a.jsx)(i.p,{children:"IK can be solved analytically for simpler robots, but for complex humanoids, numerical methods (e.g., Jacobian-based) are often necessary due to the high degrees of freedom and non-linearities."}),"\n",(0,a.jsx)(i.h4,{id:"1211-jacobian-matrix",children:"1.2.1.1 Jacobian Matrix"}),"\n",(0,a.jsx)(i.p,{children:"The Jacobian matrix relates the velocities of the robot's joints to the velocities of its end-effectors, providing a linear approximation for solving the IK problem iteratively."}),"\n",(0,a.jsx)(i.h5,{id:"12111-redundancy-and-optimization",children:"1.2.1.1.1 Redundancy and Optimization"}),"\n",(0,a.jsx)(i.p,{children:"Humanoid robots often have redundant degrees of freedom, meaning multiple joint configurations can achieve the same end-effector pose. Optimization techniques are used to find solutions that satisfy additional criteria (e.g., joint limits, obstacle avoidance)."}),"\n",(0,a.jsx)(i.h6,{id:"121111-workspace-analysis",children:"1.2.1.1.1.1 Workspace Analysis"}),"\n",(0,a.jsx)(i.p,{children:"Understanding the robot's workspace (the reachable volume for its end-effectors) is crucial for planning tasks and ensuring that desired poses are physically achievable."})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>s});var t=n(6540);const a={},o=t.createContext(a);function r(e){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);